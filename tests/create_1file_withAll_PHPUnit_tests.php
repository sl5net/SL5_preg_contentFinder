<?php
#     walks throw dir PHPUnit copies all unitTest into PHPUnitAllTest_AutoCollected.php
#     Handles duplicate global functions (defined at line start) by renaming and placing them before the test class.
#     Uses a more robust regex for global function body extraction.

// Timezone-Warnung unterdrücken
if (function_exists('date_default_timezone_set')) { // Prüfen ob Funktion existiert für ältere PHP Versionen
    date_default_timezone_set('UTC');
}


$allTestsFileName = 'PHPUnitAllTest_AutoCollected.php';
$scriptDir = pathinfo(__FILE__)['dirname'];
$dir = $scriptDir . '/PHPUnit';

echo "Script directory: " . $scriptDir . "\n";
echo "Attempting to scan directory: " . $dir . "\n";

if (!is_dir($dir)) {
    die("Error: Target directory for PHPUnit tests does not exist or is not a directory: " . $dir . "\n");
}


$extendsUniTest = 'extends PHPUnit_Framework_TestCase';

// --- Arrays für globale Funktionen ---
$globalFunctionDefinitions = array();
$globalFunctionCounts = array();
$processedGlobalFunctionsOutput = '';
// --- Ende Arrays ---

$allTestMethodsConcatenated = '';


// --- Header der generierten Datei ---
$fileHeader = '<?php' . "\n";
$fileHeader .= '// WARNING: Do not edit this file. It is auto-generated and will be overwritten!' . "\n";
$fileHeader .= '// Generated by: ' . pathinfo(__FILE__)['basename'] . ' on ' . date('Y-m-d H:i:s') . "\n\n";
$fileHeader .= '$sl5FinderFile = \'../SL5_preg_contentFinder.php\';' . "\n";
$fileHeader .= '$callbackExampleFile = \'../_callbackShortExample.php\';' . "\n\n";
$fileHeader .= '$f_sl5 = $sl5FinderFile; $c_sl5 = 0; while(!file_exists($f_sl5) && $c_sl5 < 5) { $f_sl5 = \'../\' . $f_sl5; $c_sl5++; } if(file_exists($f_sl5)) include_once $f_sl5;' . "\n";
$fileHeader .= '$f_cb_ex = $callbackExampleFile; $c_cb_ex = 0; while(!file_exists($f_cb_ex) && $c_cb_ex < 5) { $f_cb_ex = \'../\' . $f_cb_ex; $c_cb_ex++; } if(file_exists($f_cb_ex)) include_once $f_cb_ex;' . "\n\n";


$basename = pathinfo(__FILE__)['basename'];
$dh = opendir($dir); // Zurück zur einfachen Öffnung, da dies vorher funktionierte

if ($dh === false) { // Prüfung beibehalten
    die("CRITICAL ERROR: opendir failed for directory: '" . $dir . "'.\n");
}

$fileCount = 0;
echo "Successfully opened directory: " . $dir . ". Starting to read...\n";




















// Innerhalb der while ($file = readdir($dh)) Schleife:
// ...
// --- NEU: Manuelle Extraktion globaler Funktionen ---
$offset = 0;
while (preg_match('/^function\s+([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)\b/m', $file_content, $nameMatch, PREG_OFFSET_CAPTURE, $offset)) {
    $functionName = $nameMatch[1][0];
    $functionBlockStartOffset = $nameMatch[0][1]; // Start von "function funcName"

    // Finde die öffnende Klammer des Parameterteils
    $openParenPos = strpos($file_content, '(', $functionBlockStartOffset + strlen($nameMatch[0][0]));
    if ($openParenPos === false) {
        $offset = $functionBlockStartOffset + strlen($nameMatch[0][0]);
        continue;
    }
    // Finde die schließende Klammer des Parameterteils
    $closeParenPos = strpos($file_content, ')', $openParenPos);
    if ($closeParenPos === false) {
        $offset = $functionBlockStartOffset + strlen($nameMatch[0][0]);
        continue;
    }
    // Finde die öffnende Klammer des Bodys
    $openBracePos = strpos($file_content, '{', $closeParenPos);
    if ($openBracePos === false) {
        $offset = $functionBlockStartOffset + strlen($nameMatch[0][0]);
        continue;
    }

    $braceLevel = 1;
    $currentPos = $openBracePos + 1;
    $contentLength = strlen($file_content);
    $functionBodyEndOffset = -1;

    while ($currentPos < $contentLength) {
        if ($file_content[$currentPos] === '{') {
            $braceLevel++;
        } elseif ($file_content[$currentPos] === '}') {
            $braceLevel--;
            if ($braceLevel === 0) { // Korrekte schließende Klammer gefunden
                $functionBodyEndOffset = $currentPos;
                break;
            }
        }
        $currentPos++;
    }

    if ($functionBodyEndOffset !== -1) {
        // Wichtig: $functionBlockStartOffset ist der Beginn von "function name"
        // $functionBodyEndOffset ist die Position der schließenden '}'
        $fullFunctionBlock = substr($file_content, $functionBlockStartOffset, ($functionBodyEndOffset - $functionBlockStartOffset) + 1);
        
        if (!isset($globalFunctionCounts[$functionName])) {
            $globalFunctionCounts[$functionName] = 0;
            $globalFunctionDefinitions[$functionName] = $fullFunctionBlock; // Hier wird der Block gespeichert
            echo "  Found global function (brace-counted): $functionName (first time)\n";
        }
        $globalFunctionCounts[$functionName]++;
        if ($globalFunctionCounts[$functionName] > 1) {
            echo "  Found DUPLICATE global function (brace-counted): $functionName (occurrence #" . $globalFunctionCounts[$functionName] . ")\n";
        }
        $offset = $functionBodyEndOffset + 1;
    } else {
        echo "  WARNING: Could not find matching closing brace for global function $functionName starting at $functionBlockStartOffset in file $file\n";
        $offset = $openBracePos + 1;
    }
}
// --- Ende NEUE manuelle Extraktion ---




if ($dh !== false) {
    closedir($dh);
    // echo "Closed directory handle.\n"; // Weniger Output
}


// Globale Funktionen verarbeiten: Eindeutige Namen sicherstellen und Aufrufe anpassen
foreach ($globalFunctionDefinitions as $functionName => $originalBlock) {
    if ($globalFunctionCounts[$functionName] > 1) {
        $newFunctionName = $functionName . '_' . time() . rand(100, 999);
        echo "  RENAMING duplicate global function $functionName to $newFunctionName for output\n";
        
        $modifiedBlock = preg_replace(
            '/function\s+' . preg_quote($functionName, '/') . '\b/',
            'function ' . $newFunctionName,
            $originalBlock,
            1
        );
        $processedGlobalFunctionsOutput .= $modifiedBlock . "\n\n";

        // echo "    Attempting to rename calls to $functionName in test methods to $newFunctionName\n"; // Weniger Output
        $allTestMethodsConcatenated = preg_replace(
            '/\b' . preg_quote($functionName, '/') . '\b\s*\(/',
            $newFunctionName . '(',
            $allTestMethodsConcatenated
        );
    } else {
        $processedGlobalFunctionsOutput .= $originalBlock . "\n\n";
    }
}
// Die Zieldatei zusammensetzen
$finalContent = $fileHeader;
$finalContent .= $processedGlobalFunctionsOutput;
$finalContent .= "\nclass TestAll " . $extendsUniTest . " {\n";
$finalContent .= $allTestMethodsConcatenated;
$finalContent .= "\n}\n";
$finalContent .= "\n// File generation completed. Files processed for methods: $fileCount\n";
$finalContent .= "?>";
if ($fileCount < 2) {
    echo "WARNING: Only $fileCount file(s) contributed test methods. Original script expected at least 2.\n";
}
echo "\nSuccessfully prepared content for: " . $allTestsFileName . "\n";
if (file_put_contents($dir . '/' . $allTestsFileName, $finalContent) === false) {
    die("Error writing to file: " . $dir . '/' . $allTestsFileName . "\n");
} else {
    echo "File successfully written: " . $dir . '/' . $allTestsFileName . "\n";
}
?>